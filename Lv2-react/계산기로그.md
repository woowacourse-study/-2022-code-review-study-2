### 계산기로그 - 안

## Ref

Ref는 DOM 노드나 React 엘리먼트에 접근하는 방법을 제공합니다. 즉, DOM을 선택해 직접 접근하기 위해 ref를 사용합니다.

Ref를 사용해야 하는 경우

- 포커스, 텍스트 선택영역, 혹은 미디어의 재생을 관리할 때
- 애니메이션을 직접적으로 실행시킬 때
- 서드 파티 DOM 라이브러리를 React와 같이 사용할 때

react에서는 ref 사용을 지양하는편입니다.
이유는 DOM 조작 이벤트 자체가 무겁고, React 자체가 최대한 DOM을 조작안하려고 가상돔을 쓰기 때문입니다.

함수형 컴포넌트의 경우 React.createRef와 React.useRef 둘다 사용가능 하지만 React.createRef를 사용할 경우 리렌더링 될때마다 ref 값이 초기화되어 원하는 값을 얻지 못한다. 그래서 useRef를 사용한다.

리뷰어 의견

> ref 는 dom 에 접근하기 위해도 사용되지만 렌더링에 관계없이 데이터를 관리하고 싶을 때도 사용한다. 예를 들면 state 로 정보를 관리하면 state 가 변경될 때마다 렌더링이 발생하는데, 그럴 필요가 없다면 ref 를 사용해서 데이터를 관리하기도 합니다.ref 사용을 지양할 필요는 없는 것 같고, 남용하지만 않으면 좋을 것 같습니다

## state 변경

왜 state를 직접 변경하면 안되나요?

### 리액트 동작 원리

리액트는 변경사항이 한가지의 방향으로만 흘러간다.

- 데이터가 변경되면 UI가 업데이트 된다.
- 데이터(State)가 변경이 되면 → 리액트가 render() 함수를 호출해서 UI가 업데이트 된다.

```jsx
state = {
  count: 0,
};

render() {
  return (
    <>
      <span>{this.state.count}</span>
      <button onClick={() => this.state.count++}></button>
    </>
  )
}
```

위와 같이 작성을 하면 버튼을 클릭해도 count는 증가하지만 랜더되지 않아 0으로 보인다.

```jsx
<button onClick={() => {
  this.setState({count: this.state.count + 1});
}}>
```

즉, 리액트에서 제공하는 setState 함수를 호출해야 한다.

> setState 함수가 호출이 되면 이제 리액트는 현재 컴포넌트가 가지고 있는 상태와 (this.state), 업데이트 해야 하는 새로운 상태 (setState 함수의 인자로 전달된 새로운 오브젝트) 두 가지를 비교해서 업데이트가 필요한 경우 해당 컴포넌트의 render 함수를 호출한다.

### setState는 비동기 api

setState를 호출한다고 해서 무조건 바로 render 함수가 호출되는 것이 아니라,

리액트에 업데이트 요청을 하기만 하고 다시 뒤에 이어지는 코드가 실행되어진다.

비동기로 동작하기 때문에 리액트가 동시 다발적으로 요청된 여러가지의 setState를 더 효율적으로 처리 할 수 있다.

그리고, state를 업데이트 할때 이전 state 값에서 무언가가 계산이 되어지는 경우라면

컴포넌트 내의 state 값에 의존해서 계산한 값을 setState(updated)로 설정하기 보다는, setState(prevState => newState) 이렇게 이전 state 값을 받아서 그걸로 업데이트 되는 state값을 만드는 arrow 함수를 전달할 수 있는 함수 호출을 하는게 좋다.

```jsx
<button
  onClick={() => {
    this.setState(state => ({
      count: state.count + 1,
    }));
  }}
>
```

### State를 수정하면 안되는 이유

리액트에서는 상태를 직접적으로 수정하면 좋지 않다!!

> 첫번째. setState는 비동기적으로 동작한다

리액트의 setState 함수 호출은 비동기적으로 처리 됩니다.

그래서 State를 직접 수정하면서 여러번 상태를 업데이트 하는 경우 이전 업데이트 내용이 다음 업데이트 내용으로 덮어 쓰여질 수 있고,

비동기 특성으로 인해 예상치 못한 곳에서, 예상치 못한 순간에 버그가 발생 할 수 있는 위험이 있다.

> 두번째, PureComponent에서 정상적으로 동작 하지 않는다

앞에서 설명해 드린 것처럼 PureComponent는 현재 컴포넌트가 가지고 있는 상태와 (this.state), 업데이트 해야 하는 새로운 상태 (setState 함수의 인자로 전달된 새로운 오브젝트)의 레퍼런스를 비교해서 업데이트가 필요한 경우 해당 컴포넌트의 render 함수를 호출해주죠.

지금 경우는 this.stae 오브젝트를 직접적으로 수정해서 setState함수에 동일한 오브젝트를 전달하니깐, 비교 해야 하는 대상의 레퍼런스가 동일하므로 리액트는 업데이트 할 필요가 없다고 판단해서 render 함수를 호출해 주지 않아요.

이처럼, 리액트 상태 State를 직접적으로 수정하는것은 예상치 못한 문제가 발생 할 수 있기 때문에, 꼭 불변성을 유지 하는것이 좋다.
